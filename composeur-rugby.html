<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Composeur Rugby</title>
  <style>
    :root {
      color-scheme: light;
      font-family: "Segoe UI", Roboto, sans-serif;
      --bg: #f5f7fb;
      --card: #ffffff;
      --border: #d6d9e3;
      --accent: #0b3d91;
      --accent-alt: #00a8e8;
      --text-muted: #5b6270;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      background: var(--bg);
      color: #1f2633;
    }

    h1,
    h2,
    h3,
    h4 {
      margin: 0;
      font-weight: 600;
    }

    button {
      font: inherit;
      cursor: pointer;
    }

    .page {
      min-height: 100vh;
      padding: 24px clamp(12px, 4vw, 48px);
      display: flex;
      flex-direction: column;
      gap: 24px;
    }

    header {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 16px;
      justify-content: space-between;
    }

    header h1 {
      font-size: clamp(1.75rem, 2vw, 2.25rem);
    }

    .actions {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-left: auto;
      justify-content: flex-end;
    }

    .actions button,
    #import-btn {
      border: 1px solid transparent;
      padding: 8px 16px;
      border-radius: 999px;
      background: linear-gradient(135deg, var(--accent), var(--accent-alt));
      color: #fff;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .actions button.secondary {
      background: none;
      border: 1px solid var(--border);
      color: var(--accent);
    }

    .actions button:hover,
    #import-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 18px rgba(15, 52, 143, 0.2);
    }

    .layout {
      display: grid;
      grid-template-columns: clamp(300px, 24vw, 400px) 1fr;
      gap: 24px;
      align-items: start;
    }

    .card {
      background: var(--card);
      border-radius: 20px;
      padding: 20px;
      box-shadow: 0 12px 30px rgba(15, 35, 95, 0.08);
      border: 1px solid rgba(12, 41, 92, 0.06);
    }

    .sidebar {
      display: flex;
      flex-direction: column;
      gap: 16px;
      align-self: stretch;
      min-height: 100%;
      border-right: 1px solid var(--border);
      position: sticky;
      top: 24px;
      max-height: calc(100vh - 48px);
      overflow-y: auto;
    }

    .sidebar h2 {
      margin-bottom: 4px;
    }

    .sidebar #import-btn {
      align-self: flex-start;
    }

    .sidebar .pool {
      display: flex;
      flex-direction: column;
      gap: 12px;
      flex: 1;
    }

    .sidebar .pool-list {
      flex: 1;
      min-height: 160px;
      overflow-y: auto;
    }

    textarea {
      width: 100%;
      min-height: 140px;
      border-radius: 16px;
      border: 1px solid var(--border);
      padding: 16px;
      resize: vertical;
      font: inherit;
    }

    .subtitle {
      color: var(--text-muted);
      font-size: 0.95rem;
      margin-bottom: 16px;
    }

    .pool-list,
    .slot-content {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .pool-list,
    .slot {
      padding: 12px;
      border-radius: 16px;
      border: 1px dashed var(--border);
      background: #f9fbff;
    }

    .pool-list.empty::after {
      content: attr(data-empty-label);
      color: var(--text-muted);
      font-style: italic;
      text-align: center;
      padding: 24px 0;
    }

    .player {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 14px;
      border-radius: 14px;
      background: #fff;
      border: 1px solid rgba(15, 52, 143, 0.12);
      box-shadow: 0 4px 12px rgba(15, 52, 143, 0.08);
      gap: 12px;
    }

    .player .name {
      flex: 1;
      font-weight: 500;
      font-size: 0.95rem;
    }

    .player-actions {
      display: flex;
      gap: 6px;
    }

    .player button {
      border: none;
      background: none;
      color: var(--text-muted);
      font-size: 1rem;
      padding: 4px 6px;
      border-radius: 50%;
    }

    .player button:hover {
      background: rgba(15, 52, 143, 0.08);
      color: var(--accent);
    }

    .field-card {
      position: relative;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      gap: 16px;
      background: linear-gradient(180deg, #0c8f4a 0%, #0a6f3b 100%);
      color: #fff;
      min-height: 680px;
    }

    .field-card::before {
      content: "";
      position: absolute;
      inset: 16px;
      border-radius: 18px;
      border: 2px solid rgba(255, 255, 255, 0.25);
      pointer-events: none;
    }

    .field-card::after {
      content: "";
      position: absolute;
      inset: 16px;
      border-radius: 18px;
      background-image: repeating-linear-gradient(
          to bottom,
          rgba(255, 255, 255, 0.14),
          rgba(255, 255, 255, 0.14) 1px,
          transparent 1px,
          transparent calc(100% / 6)
        ),
        repeating-linear-gradient(
          to right,
          rgba(255, 255, 255, 0.12),
          rgba(255, 255, 255, 0.12) 1px,
          transparent 1px,
          transparent calc(100% / 7)
        );
      opacity: 0.45;
      pointer-events: none;
    }

    .field-header {
      position: relative;
      z-index: 1;
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      align-items: flex-start;
      gap: 8px 16px;
    }

    .field-header h2 {
      font-size: 1.6rem;
      color: #fff;
    }

    .field-header .subtitle {
      margin: 0;
      color: rgba(255, 255, 255, 0.82);
      max-width: 420px;
    }

    .lineup-grid {
      position: relative;
      z-index: 1;
      flex: 1;
      display: grid;
      grid-template-columns: repeat(7, minmax(70px, 1fr));
      grid-template-rows: repeat(6, minmax(95px, auto));
      gap: 12px;
      padding: 8px 0 12px;
    }

    .position-card {
      display: flex;
      flex-direction: column;
      align-items: stretch;
      gap: 8px;
      background: rgba(255, 255, 255, 0.92);
      border-radius: 14px;
      padding: 12px;
      box-shadow: 0 8px 18px rgba(8, 38, 70, 0.25);
      color: #1f2633;
      width: min(210px, 100%);
      justify-self: center;
    }

    .position-number {
      display: inline-flex;
      align-self: flex-start;
      padding: 4px 10px;
      border-radius: 999px;
      background: rgba(11, 61, 145, 0.12);
      color: var(--accent);
      font-weight: 600;
      font-size: 0.9rem;
    }

    .position-label {
      font-size: 0.95rem;
      font-weight: 600;
    }

    .slots {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .slot {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-height: 78px;
      border-radius: 12px;
      border: 1px dashed rgba(11, 61, 145, 0.25);
      background: rgba(11, 61, 145, 0.05);
      padding: 10px;
      transition: border-color 0.2s ease, background 0.2s ease;
    }

    .slot-label {
      font-size: 0.75rem;
      font-weight: 600;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: rgba(11, 61, 145, 0.85);
    }

    .slot-placeholder {
      text-align: center;
      color: var(--text-muted);
      font-size: 0.8rem;
      padding: 6px 4px;
    }

    .slot.empty {
      justify-content: center;
    }

    .slot.empty .slot-label {
      color: rgba(31, 38, 51, 0.6);
    }

    .slot.empty .slot-content {
      display: none;
    }

    .slot.drag-over {
      border-style: solid;
      border-color: var(--accent);
      background: rgba(11, 61, 145, 0.18);
    }

    .editor-only {
      display: contents;
    }

    .layout.editor-only {
      display: grid;
    }

    .actions.editor-only {
      display: flex;
    }

    @media (max-width: 900px) {
      .layout {
        grid-template-columns: 1fr;
      }

      .sidebar {
        position: static;
        max-height: none;
        overflow: visible;
      }

      .field-card {
        min-height: 640px;
      }
    }

    @media (max-width: 720px) {
      header {
        flex-direction: column;
        align-items: flex-start;
      }

      .actions {
        width: 100%;
        justify-content: flex-start;
      }

      .actions button {
        flex: 1 1 auto;
      }

      .lineup-grid {
        grid-template-columns: repeat(7, minmax(48px, 1fr));
        gap: 8px;
      }

      .position-card {
        width: 100%;
        padding: 10px;
      }

      .position-label {
        font-size: 0.85rem;
      }
    }

    @media (max-width: 600px) {
      .player {
        flex-direction: column;
        align-items: flex-start;
      }

      .player button {
        align-self: flex-end;
      }
    }

    @media (max-width: 480px) {
      .field-card {
        padding: 16px;
      }

      .position-number {
        font-size: 0.85rem;
      }
    }

    @media print {
      body {
        background: #fff;
      }

      header .actions,
      .sidebar {
        display: none !important;
      }

      .layout {
        grid-template-columns: 1fr;
      }

      .field-card {
        box-shadow: none;
        background: #fff;
        color: #000;
      }

      .field-card::before,
      .field-card::after {
        display: none;
      }

      .position-card {
        box-shadow: none;
        border: 1px solid #ccc;
      }
    }
  </style>
</head>
<body>
  <div class="page">
    <header>
      <h1>Composeur de XV de Rugby</h1>
      <div class="actions editor-only">
        <button id="save-btn">Sauvegarder</button>
        <button id="load-btn" class="secondary">Charger</button>
        <button id="print-btn" class="secondary">Imprimer</button>
        <button id="reset-btn" class="secondary">Réinitialiser</button>
      </div>
    </header>

    <div class="layout editor-only">
      <section class="card sidebar">
        <div>
          <h2>Joueurs présents</h2>
          <p class="subtitle">Commencez par entrer tous vos joueurs ici. Puis glissez-les dans la composition.</p>
        </div>
        <textarea id="import-input" placeholder="Ex. Antoine Dupont; Romain Ntamack, Grégory Alldritt"></textarea>
        <button id="import-btn">Ajouter les joueurs</button>
        <div class="pool">
          <h3>Effectif du jour</h3>
          <div id="pool-list" class="pool-list" data-drop-target="pool" data-empty-label="Aucun joueur"></div>
        </div>
      </section>

      <section class="card field-card">
        <div class="field-header">
          <div>
            <h2>Composition du XV</h2>
            <p class="subtitle">Placez un titulaire et un remplaçant à chaque poste tout en conservant la numérotation historique du rugby.</p>
          </div>
        </div>
        <div id="lineup-grid" class="lineup-grid"></div>
      </section>
    </div>
  </div>

  <script>
    const STORAGE_KEY = "composeur-rugby-state";

    const uid = (() => {
      let inc = 0;
      return () => `p_${Date.now().toString(36)}_${(inc++).toString(36)}`;
    })();

    const POSITIONS = [
      { number: 11, label: "Ailier gauche", row: 1, col: 1 },
      { number: 15, label: "Arrière", row: 1, col: 4 },
      { number: 14, label: "Ailier droit", row: 1, col: 7 },
      { number: 12, label: "Centre intérieur", row: 2, col: 3 },
      { number: 13, label: "Centre extérieur", row: 2, col: 5 },
      { number: 10, label: "Demi d'ouverture", row: 3, col: 3 },
      { number: 9, label: "Demi de mêlée", row: 3, col: 5 },
      { number: 6, label: "Troisième ligne aile", row: 4, col: 2 },
      { number: 8, label: "Troisième ligne centre", row: 4, col: 4 },
      { number: 7, label: "Troisième ligne aile", row: 4, col: 6 },
      { number: 4, label: "Deuxième ligne", row: 5, col: 3 },
      { number: 5, label: "Deuxième ligne", row: 5, col: 5 },
      { number: 1, label: "Pilier gauche", row: 6, col: 2 },
      { number: 2, label: "Talonneur", row: 6, col: 4 },
      { number: 3, label: "Pilier droit", row: 6, col: 6 }
    ];

    const createEmptyLineup = () => {
      const lineup = {};
      POSITIONS.forEach(({ number }) => {
        lineup[number] = { starter: null, bench: null };
      });
      return lineup;
    };

    const normalizePlayer = (player) => {
      if (!player || typeof player !== "object") return null;
      if (typeof player.id !== "string" || typeof player.name !== "string") return null;
      return { id: player.id, name: player.name };
    };

    const defaultState = () => ({
      pool: [],
      lineup: createEmptyLineup(),
      playersText: ""
    });

    const parseNames = (raw) => {
      if (!raw) return [];
      return raw
        .split(/[
;,]+/)
        .map((name) => name.trim())
        .filter((name) => name.length > 0);
    };

    const saveState = () => {
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      } catch (err) {
        console.warn("Impossible d'enregistrer l'état", err);
      }
    };

    const loadState = () => {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (!parsed || typeof parsed !== "object") return null;

        const lineup = createEmptyLineup();
        const poolMap = new Map();

        const addToPool = (player) => {
          const normalized = normalizePlayer(player);
          if (!normalized) return;
          poolMap.set(normalized.id, normalized);
        };

        if (Array.isArray(parsed.pool)) {
          parsed.pool.forEach(addToPool);
        }

        if (parsed.lineup && typeof parsed.lineup === "object") {
          POSITIONS.forEach(({ number }) => {
            const slot = parsed.lineup[number];
            if (!slot || typeof slot !== "object") return;
            const starter = normalizePlayer(slot.starter);
            const bench = normalizePlayer(slot.bench);
            if (starter) {
              lineup[number].starter = starter;
              poolMap.delete(starter.id);
            }
            if (bench) {
              lineup[number].bench = bench;
              poolMap.delete(bench.id);
            }
          });
        }

        if (Array.isArray(parsed.teams)) {
          parsed.teams.forEach((team) => {
            if (!team || typeof team !== "object") return;
            (team.starters || []).forEach(addToPool);
            (team.bench || []).forEach(addToPool);
          });
        }

        const pool = Array.from(poolMap.values());
        pool.sort((a, b) => a.name.localeCompare(b.name, "fr"));

        return {
          pool,
          lineup,
          playersText: typeof parsed.playersText === "string" ? parsed.playersText : ""
        };
      } catch (err) {
        console.warn("Impossible de charger l'état", err);
        return null;
      }
    };

    const findLocation = (playerId) => {
      const poolIndex = state.pool.findIndex((p) => p.id === playerId);
      if (poolIndex !== -1) {
        return { type: "pool", index: poolIndex };
      }
      for (const { number } of POSITIONS) {
        const slot = state.lineup[number];
        if (!slot) continue;
        if (slot.starter && slot.starter.id === playerId) {
          return { type: "starter", position: number };
        }
        if (slot.bench && slot.bench.id === playerId) {
          return { type: "bench", position: number };
        }
      }
      return null;
    };

    const removeFromLocation = (location) => {
      if (!location) return null;
      if (location.type === "pool") {
        return state.pool.splice(location.index, 1)[0] || null;
      }
      const slot = state.lineup[location.position];
      if (!slot) return null;
      if (location.type === "starter") {
        const player = slot.starter;
        slot.starter = null;
        return player;
      }
      if (location.type === "bench") {
        const player = slot.bench;
        slot.bench = null;
        return player;
      }
      return null;
    };

    const moveToPool = (playerId) => {
      const location = findLocation(playerId);
      const player = removeFromLocation(location);
      if (!player) return;
      if (!state.pool.some((p) => p.id === player.id)) {
        state.pool.push(player);
        state.pool.sort((a, b) => a.name.localeCompare(b.name, "fr"));
      }
    };

    const placePlayer = (playerId, positionNumber, role) => {
      const slot = state.lineup[positionNumber];
      if (!slot || (role !== "starter" && role !== "bench")) return;
      const location = findLocation(playerId);
      const player = removeFromLocation(location);
      if (!player) return;
      const previous = slot[role];
      if (previous && previous.id !== player.id) {
        if (!state.pool.some((p) => p.id === previous.id)) {
          state.pool.push(previous);
        }
      }
      slot[role] = player;
      state.pool = state.pool.filter((p) => p.id !== player.id);
      state.pool.sort((a, b) => a.name.localeCompare(b.name, "fr"));
    };

    const importPlayers = () => {
      const names = parseNames(state.playersText);
      if (!names.length) return;
      const existing = new Set();
      state.pool.forEach((player) => existing.add(player.name.toLowerCase()));
      POSITIONS.forEach(({ number }) => {
        const slot = state.lineup[number];
        if (slot.starter) existing.add(slot.starter.name.toLowerCase());
        if (slot.bench) existing.add(slot.bench.name.toLowerCase());
      });
      names.forEach((name) => {
        const key = name.toLowerCase();
        if (existing.has(key)) return;
        existing.add(key);
        state.pool.push({ id: uid(), name });
      });
      state.pool.sort((a, b) => a.name.localeCompare(b.name, "fr"));
      state.playersText = "";
      render();
      saveState();
    };

    const deletePlayer = (playerId) => {
      const location = findLocation(playerId);
      removeFromLocation(location);
      render();
      saveState();
    };

    const resetState = () => {
      state = defaultState();
      render();
      saveState();
    };

    let state = loadState() || defaultState();

    const buildPlayerElement = (player, context) => {
      const item = document.createElement("div");
      item.className = "player";
      item.draggable = true;
      item.dataset.playerId = player.id;
      const safeName = player.name.replace(/[&<>"']/g, (char) => {
        switch (char) {
          case "&":
            return "&amp;";
          case "<":
            return "&lt;";
          case ">":
            return "&gt;";
          case '"':
            return "&quot;";
          case "'":
            return "&#39;";
          default:
            return char;
        }
      });
      item.innerHTML = `
        <span class="name">${safeName}</span>
        <div class="player-actions">
          ${context !== "pool" ? '<button type="button" data-action="send-to-pool" title="Retour pool">↩</button>' : ""}
          <button type="button" data-action="delete-player" title="Supprimer" aria-label="Supprimer" data-context="${context}">✕</button>
        </div>
      `;
      return item;
    };

    const renderPool = () => {
      const pool = document.getElementById("pool-list");
      pool.innerHTML = "";
      if (state.pool.length === 0) {
        pool.classList.add("empty");
      } else {
        pool.classList.remove("empty");
      }
      state.pool.forEach((player) => {
        const item = buildPlayerElement(player, "pool");
        pool.appendChild(item);
      });
    };

    const renderLineup = () => {
      const grid = document.getElementById("lineup-grid");
      grid.innerHTML = "";
      POSITIONS.forEach((position) => {
        const card = document.createElement("div");
        card.className = "position-card";
        card.style.gridColumnStart = position.col;
        card.style.gridRowStart = position.row;

        const number = document.createElement("div");
        number.className = "position-number";
        number.textContent = String(position.number);
        card.appendChild(number);

        const label = document.createElement("div");
        label.className = "position-label";
        label.textContent = position.label;
        card.appendChild(label);

        const slots = document.createElement("div");
        slots.className = "slots";
        card.appendChild(slots);

        ["starter", "bench"].forEach((role) => {
          const slot = document.createElement("div");
          slot.className = "slot";
          slot.dataset.dropTarget = "slot";
          slot.dataset.position = String(position.number);
          slot.dataset.role = role;

          const slotLabel = document.createElement("span");
          slotLabel.className = "slot-label";
          slotLabel.textContent = role === "starter" ? "Titulaire" : "Remplaçant";
          slot.appendChild(slotLabel);

          const placeholder = document.createElement("span");
          placeholder.className = "slot-placeholder";
          placeholder.textContent = role === "starter" ? "Glissez le titulaire ici" : "Glissez le remplaçant ici";

          const content = document.createElement("div");
          content.className = "slot-content";

          const player = state.lineup[position.number][role];
          if (player) {
            slot.classList.remove("empty");
            const element = buildPlayerElement(player, "slot");
            content.appendChild(element);
          } else {
            slot.classList.add("empty");
            slot.appendChild(placeholder);
          }

          slot.appendChild(content);
          slots.appendChild(slot);
        });

        grid.appendChild(card);
      });
    };

    const attachDnDHandlers = () => {
      document.querySelectorAll(".player").forEach((el) => {
        el.addEventListener("dragstart", (event) => {
          const id = el.dataset.playerId;
          event.dataTransfer.setData("text/plain", id);
          event.dataTransfer.effectAllowed = "move";
        });
      });

      document.querySelectorAll("[data-drop-target]").forEach((zone) => {
        zone.addEventListener("dragover", (event) => {
          event.preventDefault();
          event.dataTransfer.dropEffect = "move";
        });
        zone.addEventListener("dragenter", (event) => {
          event.preventDefault();
          if (zone.classList.contains("slot")) {
            zone.classList.add("drag-over");
          }
        });
        zone.addEventListener("dragleave", (event) => {
          if (!zone.contains(event.relatedTarget) && zone.classList.contains("slot")) {
            zone.classList.remove("drag-over");
          }
        });
        zone.addEventListener("drop", (event) => {
          event.preventDefault();
          const playerId = event.dataTransfer.getData("text/plain");
          const target = zone.dataset.dropTarget;
          if (zone.classList.contains("slot")) {
            zone.classList.remove("drag-over");
          }
          if (!playerId || !target) return;
          if (target === "pool") {
            moveToPool(playerId);
          } else if (target === "slot") {
            const position = Number(zone.dataset.position);
            const role = zone.dataset.role;
            placePlayer(playerId, position, role);
          }
          render();
          saveState();
        });
      });
    };

    const render = () => {
      const textarea = document.getElementById("import-input");
      if (document.activeElement !== textarea) {
        textarea.value = state.playersText;
      }
      renderPool();
      renderLineup();
      attachDnDHandlers();
    };

    document.addEventListener("input", (event) => {
      if (event.target.id === "import-input") {
        state.playersText = event.target.value;
      }
    });

    document.addEventListener("click", (event) => {
      const action = event.target.dataset.action;
      if (!action) return;
      const playerElement = event.target.closest(".player");
      if (!playerElement) return;
      const playerId = playerElement.dataset.playerId;
      if (!playerId) return;
      if (action === "delete-player") {
        if (event.target.dataset.context === "pool") {
          deletePlayer(playerId);
        } else {
          moveToPool(playerId);
          render();
          saveState();
        }
      }
      if (action === "send-to-pool") {
        moveToPool(playerId);
        render();
        saveState();
      }
    });

    document.getElementById("import-btn").addEventListener("click", () => {
      importPlayers();
    });

    document.getElementById("save-btn").addEventListener("click", () => {
      saveState();
    });

    document.getElementById("load-btn").addEventListener("click", () => {
      const loaded = loadState();
      if (loaded) {
        state = loaded;
        render();
      }
    });

    document.getElementById("reset-btn").addEventListener("click", () => {
      if (confirm("Réinitialiser le composeur ?")) {
        resetState();
      }
    });

    document.getElementById("print-btn").addEventListener("click", () => {
      window.print();
    });

    const poolList = document.getElementById("pool-list");
    poolList.addEventListener("dragenter", (event) => {
      event.preventDefault();
    });

    render();
  </script>
</body>
</html>
